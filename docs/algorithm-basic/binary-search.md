---
title: Binary Search
author: njoop
---

## Binary Search คืออะไร
Binary Search หรือการค้นหาแบบทวิภาค เป็นวิธีการค้นหาข้อมูลที่ใช้กับข้อมูลที่**มีการเรียงลำดับแล้ว** โดยจะนำข้อมูลมาแบ่งครึ่ง และพิจารณาว่าข้อมูลที่ต้องการจะค้นหาอยู่ที่ครึ่งไหน และทำซ้ำๆ ไปเรื่อยๆ

Binary search สามารถทำได้โดยมีขั้นตอนดังนี้

1. กำหนดตำแหน่งข้อมูลที่น้อย และมากที่สุดที่เป็นไปได้ (แทนค่าด้วยตัวแปร $L$, $R$ ตามลำดับ โดยช่วง $[L, R]$ จะเป็นช่วงที่เป็นไปได้ที่มจะมีข้อมูลที่เราต้องการค้นหาอยู่)
2. หาค่าตรงกลาง ระหว่าง $L$ กับ $R$ ให้ค่านี้เป็น $mid$
3. ตรวจสอบข้อมูลในตำแหน่ง $mid$ 
    - ถ้าเกิดข้อมูลเป็นสิ่งที่เราค้นหา ก็จบการทำงาน โดยเราพบเจอข้อมูลที่เราค้นหาแล้ว
    - ถ้าเกิดข้อมูลน้อยกว่าสิ่งที่เราค้นหา ให้ค่า $L = mid+1$ (เพราะไม่มีทางที่ข้อมูลที่เราต้องการ อยู่ระหว่าง $L$ และ $mid$ แน่นอน) 
    - ถ้าเกิดข้อมูลมากกว่าสิ่งที่เราค้นหา ให้ค่า $R = mid-1$ (หลักการเดียวกันกับข้างต้น)
4. ทำซ้ำไปเรื่อยๆ จนกว่า $L > R$ (แสดงว่าไม่มีข้อมูลที่ค้นหาอยู่) หรือพบข้อมูลที่ต้องการ


!!! warning "หมายเหตุ"
    1. สามารถหาค่า $mid$ ได้หลายวิธี โดยปกติมักทำโดยการนำค่า $\frac{L+R}{2}$ ปัดเศษลง แต่ก็สามารถปัดเศษขึ้นได้เหมือนกัน
    2. การกำหนดค่า $L$ และ $R$ ใหม่ ก็สามารถทำได้หลายวิธี เช่น ถ้าเกิดมีข้อมูลซ้ำ และเราต้องการหาข้อมูลที่ตรงและมีตำแหน่งมากที่สุด อาจเปลี่ยนจาก $R = mid-1$ เป็น $R = mid$ แทน

## Binary search ในชีวิตประจำวัน
เราอาจใช้ Binary search ในชีวิตประจำวันโดยไม่รู้ตัว ตัวอย่างการใช้งานเช่น:

มีหนังสือ 8 เล่ม โดยที่ชื่อหนังสือแต่ละเล่มนั้น **เรียงลำดับตามพจนานุกรม** ตามตาราง

| หนังสือเล่มที่ | ชื่อหนังสือ |
| ----- | ----------- |
| 1 | Ascendance of a bookworm |
| 2 | Harry potter |
| 3 | Jobless Reincarnation |
| 4 | Lycoris Recoil |
| 5 | Omniscient Reader's Viewpoint |
| 6 | Reverend Insanity |
| 7 | Secrets of the Silent Witch |
| 8 | The Beginning After The End |

ถ้าเกิดต้องการหาว่า "Omniscient Reader's Viewpoint" เป็นหนังสือเล่มที่เท่าไหร่ จะมีวิธีหลักๆ อยู่ 2 วิธี คือ

### วิธีที่ 1 (Sequential search หรือ Linear search)

1. ตรวจสอบหนังสือเล่มที่ 1 สังเกตว่าหนังสือเล่มนั้นไม่ใช่ "Omniscient Reader's Viewpoint" จึงไปดูหนังสือเล่มต่อไป
2. ตรวจสอบหนังสือเล่มที่ 2 สังเกตว่าหนังสือเล่มนั้นไม่ใช่ "Omniscient Reader's Viewpoint" จึงไปดูหนังสือเล่มต่อไป
3. ทำซ้ำไปเรื่อยๆ จนเจอ "Omniscient Reader's Viewpoint" หรือดูหนังสือครบทุกเล่ม

### วิธีที่ 2 (Binary search)

1. สังเกตว่า มีหนังสือ 8 เล่ม
2. ตรวจสอบหนังสือเล่มที่ 4 หรือ 5 เนื่องจากทั้งตำแหน่งกึ่งกลางอาจเป็น 4 หรือ 5 ก็ได้ ในที่นี้เราเลือกหนังสือเล่มที่ 4 สังเกตว่า "Lycoris recoil" มาก่อน "Omniscient Reader's Viewpoint" ตามลำดับพจนานุกรม ดังนั้น หนังสือเล่มที่ 1 ถึง 4 ไม่มีทางเป็น "Omniscient Reader's Viewpoint" แน่นอน หนังสือที่เป็นไปได้จึงเป็นหนังสือเล่มที่ 5 ถึง 8
3. ตรวจสอบหนังสือเล่มที่ 6 หรือ 7 ในที่นี้เราเลือกหนังสือเล่มที่ 7 สังเกตว่า "Secrets of the Silent Witch" มาหลัง "Omniscient Reader's Viewpoint" ตามลำดับพจนานุกรม ดังนั้น หนังสือที่เป็นไปได้จึงเป็นหนังสือเล่มที่ 5 ถึง 6
4.  ตรวจสอบหนังสือเล่มที่ 5 ซึ่งมีชื่อ "Omniscient Reader's Viewpoint" ตามที่เราต้องการ จึงสามารถสรุปได้ว่า "Omniscient Reader's Viewpoint" เป็นหนังสือเล่มที่ 5

## Binary search vs Sequential search
สังเกตว่า วิธีที่ 1 จำเป็นต้องตรวจสอบหนังสืออย่างมาก 8 เล่ม แต่วิธีที่ 2 จำเป็นต้องตรวจสอบหนังสือแค่ 3 เล่ม ซึ่งดูเหมือนจะไม่ได้เร็วขึ้นกว่ากันมาก แต่ถ้าเกิดมีหนังสือ 1 ล้านเล่ม วิธีที่ 2 จะตรวจสอบหนังสือแค่ 20 เล่มเท่านั้น

ถ้าเกิดมีหนังสือ n เล่ม 

- วิธีที่ 1 (sequential search) ตรวจสอบอย่างมาก n ครั้ง หรือ $O(n)$
- วิธีที่ 2 (binary search) ตรวจสอบอย่างมาก $\lceil log_2 n\rceil$ ครั้ง หรือ $O(\log n)$

!!! info "ข้อสังเกต"
    Binary search สามารถใช้ได้กับข้อมูลที่มีการเรียงแล้วเท่านั้น

## Binary Search กับ Competitive Programming

!!! abstract "โจทย์ตัวอย่าง"
    รับจำนวนเต็มมา $n$ จำนวน $a_1, a_2, ..., a_n$ โดยที่ $a_i \leq a_{i+1}$ สำหรับ $1 \leq i \leq n-1$ 
    
    ต้องการถาม $q$ คำถาม ในคำถามที่ $i$ ให้ตอบว่ามีกี่ตัวเลขใน $n$ ตัวเลขนี้ ที่มีค่าอยู่ระหว่าง $x_i$ และ $y_i$ โดยที่ constraints เป็นดังนี้

    $1 \leq n, q \leq 100,000$

    $1 \leq a_1, ..., a_n \leq 10^9$

สังเกตว่า ในโจทย์ข้อนี้ ถ้าหากตรวจสอบทุกตัวเลข ในแต่ละคำถาม จะใช้เวลา $O(nq)$ ซึ่งไม่พอต่อขอบเขตข้อมูลของโจทย์

เราสามารถหาว่า มีเลขกี่ตัวที่น้อยกว่าหรือเท่ากับ $A$ ได้ ใน $O(\log n)$ ด้วย binary search โดย:

1. กำหนดตำแหน่งข้อมูลที่น้อย และมากที่สุดที่เป็นไปได้ (ให้ $L=0,R=n$)
2. หาค่าตรงกลาง ระหว่าง $L$ กับ $R$ ให้ค่านี้เป็น $mid$
3. ตรวจสอบข้อมูลในตำแหน่ง $mid$ 
    - ถ้าเกิดข้อมูลน้อยกว่าหรือเท่ากับเลขที่เราค้นหา ให้ค่า $L = mid+1$ 
    - ถ้าเกิดไม่ใช่ ให้ค่า $R = mid$
4. ทำซ้ำไปเรื่อยๆ จนกว่า $L = R$
5. จะได้ว่า $L$ เป็นตำแหน่งของเลขตัวแรก ที่มีค่ามากกว่า $A$ ดังนั้นจำนวนเลขกี่ตัวที่น้อยกว่าหรือเท่ากับ $A$ มี $L$ จำนวน

!!! info "ข้อสังเกต"
    การ binary search ในที่นี้ จะมีลักษณะเหมือนฟังก์ชั่น `std::upper_bound` ในภาษา C++ ดังนั้นสามารถใช้ฟังก์ชั่นนี้โดยตรงได้เลย (ฟังก์ชั่น `std::upper_bound` ใช้ binary search ในการค้นหาตำแหน่ง) 

ในการแก้โจทย์ข้อนี้ เราจะหาตำแหน่งของ 2 ตัวเลข คือ จำนวนตัวเลขที่น้อยกว่าหรือเท่ากับ $x_i-1$ (ให้ค่าเป็น $P$) และจำนวนตัวเลขที่น้อยกว่าหรือเท่ากับ $y_i$ (ให้ค่าเป็น $Q$) สำหรับแต่ละคำถาม สามารถตอบ $Q-P$ ได้เลย

สรุป Time complexity:

- การรับข้อมูล: $O(n)$
- ถามแต่ละคำถาม: $O(\log n) \rightarrow$ ถาม 2$q$ ครั้ง จะได้ time complexity เป็น $O(q \log n)$

Time complexity รวม: $O(n+q \log n)$ ซึ่งเพียงพอต่อความต้องการของโจทย์

ตัวอย่างโค้ด (ไม่ใช้ `std::upper_bound`)

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    // example code here
}
```

!!! warning "ข้อผิดพลาดที่เกิดขึ้นบ่อย"
    1. การที่เราหาค่า mid โดยการใช้สมการ $(L+R)/2$ อาจทำให้เกิด overflow ขึ้นได้ เพราะระหว่างการคำนวณ ค่า $(L+R)$ จะมีค่ามากกว่าทั้งค่า L และ R ที่โจทย์กำหนด โดยสามารถแก้ได้โดยการใช้สมการ $L + (R-L)/2$

ตัวอย่างโค้ด (ใช้ `std::upper_bound`)

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    // example code here
}
```

!!! note "คำแนะนำ"
    ถ้าเกิดข้อมูลไม่ได้เรียงมาให้ กล่าวคือ $a_i \leq a_{i+1}$ ไม่เป็นจริงเสมอไป สามารถจัดเรียงข้อมูลโดยใช้ `std::sort` (หรืออาจเป็นฟังก์ชั่นอื่นในภาษาอื่น) ก่อน เพื่อทำขึ้นตอนต่อไปได้ ซึ่งมี Time complexity เป็น $O(n \log n)$ 

## Binary Search on Answer

ถ้าเกิดเรามีฟังก์ชั่น $f(x)$ ที่คืนค่าได้ 2 ค่า คือ จริง หรือ เท็จ เราสามารถ binary search หาค่าที่มากที่สุด หรือน้อยที่สุดที่ $f(x)$ เป็นจริงได้ แต่ $f(x)$ จะต้องมีสมบัติเป็นโมโนโทน (ฟังก์ชั่นจะต้องไม่เพิ่ม หรือ ไม่ลด อย่างใดอย่างหนึ่ง)

โดยทั่วไปจะมี 2 กรณี คือ

- ถ้า $f(x)$ เป็นจริง แล้ว $f(y)$ จะเป็นจริงสำหรับทุก y >= x
- ถ้า $f(x)$ เป็นเท็จ แล้ว $f(y)$ จะเป็นเท็จสำหรับทุก y <= x
- ต้องการหา $f(x)$ ที่น้อยที่สุดที่ทำให้ $f(x)$ เป็นจริง

และ

- ถ้า $f(x)$ เป็นจริง แล้ว $f(y)$ จะเป็นเท็จสำหรับทุก y >= x
- ถ้า $f(x)$ เป็นเท็จ แล้ว $f(y)$ จะเป็นจริงสำหรับทุก y <= x
- ต้องการหา $f(x)$ ที่มากที่สุดที่ทำให้ $f(x)$ เป็นจริง

ตัวอย่างโค้ด กรณีที่ 1

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    // example code here
}
```

// คำอธิบาย

ตัวอย่างโค้ด กรณีที่ 2

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    // example code here
}
```

// คำอธิบาย

ถ้าการคำนวณหาค่า $f(x)$ ใดๆ ใช้เวลา $O(T(n))$ แล้วสามารถหาค่า $x$ ที่น้อยที่สุด หรือมากที่สุดที่ทำให้ $f(x)$ เป็นจริงได้ในเวลา $O(T(n) \log n)$

!!! abstract "โจทย์ตัวอย่าง: กุลีแห่งท่าเรือ - การแข่งขันคอมพิวเตอร์โอลิมปิกระดับชาติครั้งที่ 11"
    <a href="https://programming.in.th/tasks/toi11_labor"><u>โจทย์</u></a>

    โจทย์โดยย่อ: มีกุลีทั้งหมด $m$ คน กุลีคนที่ $i$ จะใช้เวลา $t_i$ นาที ในการขนสินค้า 1 ชิ้นขึ้นเรือ อยากทราบว่า ถ้าต้องการขนสินค้า $n$ ชิ้นขึ้นเรือ โดยใช้กุลีทั้ง $m$ คน จะใช้เวลาน้อยที่สุดเท่าไหร่ โดยมี constraints ดังนี้

    $2\leq m\leq 10^6$

    $1\leq n\leq 10^{12}$

    $1\leq t_i\leq 10^6$ สำหรับ $1\leq i\leq m$

นิยามให้ $f(x)$ เป็นจริงเมื่อถ้าเกิดสามารถขนสินค้า $n$ ชิ้นขึ้นเรือภายในระยะเวลา $x$

ในการคำนวณค่า $f(x)$ สามารถตรวจสอบทุกกุลี ว่าสามารถขนสินค้าได้กี่ชิ้นภายในเวลา $x$ ทำให้ใช้ $O(m)$

และ $f(x)$ เป็นฟังก์ชั่น monotonic เพราะถ้าเกิดสามารถขนสินค้าได้ครบในเวลา $x$ ก็สามารถขนสินค้าได้ครบในเวลา $\geq x$ และกลับกัน

เราสามารถ Binary search บน $f(x)$ เพื่อหาค่า $x$ ที่น้อยที่สุดที่ทำให้ $f(x)$ เป็นจริงได้ ใน $O\!\bigl(m \log (n \cdot t_{\max})\bigr)$ ซึ่งเพียงพอสำหรับการแก้โจทย์

ตัวอย่างโค้ด

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, m, arr[1000010], l=1, r=1e18, mid;
long long find_sum(long long k) {
    long long sum = 0;
    for(int i=1; i<=m; i++) {
        sum += k/arr[i];
    }
    return sum;
}
int main() {
    cin.tie(0)->sync_with_stdio(0);
    cin >> m >> n;
    for(int i=1; i<=m; i++) {
        cin >> arr[i];
    }
    while(l < r) {
        mid = (l+r)/2;
        if(find_sum(mid) < n) {
            l = mid+1;
        } else {
            r = mid;
        }
    }
    cout << l;
    return 0;
}
```

## โจทย์ฝึก

// To be added