---
title: Binary Search
author: njoop
---

## Binary Search คืออะไร

Binary Search หรือการค้นหาแบบทวิภาค เป็นวิธีการค้นหาข้อมูลที่ใช้กับข้อมูลที่**มีการเรียงลำดับแล้ว** โดยจะนำข้อมูลมาแบ่งครึ่ง และพิจารณาว่าข้อมูลที่ต้องการจะค้นหาอยู่ที่ครึ่งไหน และทำซ้ำๆ ไปเรื่อยๆ

Binary search สามารถทำได้โดยมีขั้นตอนดังนี้

1. กำหนดตำแหน่งข้อมูลที่น้อย และมากที่สุดที่เป็นไปได้ (แทนค่าด้วยตัวแปร $L$, $R$ ตามลำดับ โดยช่วง $[L, R]$ จะเป็นช่วงที่เป็นไปได้ที่มจะมีข้อมูลที่เราต้องการค้นหาอยู่)
2. หาค่าตรงกลาง ระหว่าง $L$ กับ $R$ ให้ค่านี้เป็น $mid$
3. ตรวจสอบข้อมูลในตำแหน่ง $mid$
    - ถ้าเกิดข้อมูลเป็นสิ่งที่เราค้นหา ก็จบการทำงาน โดยเราพบเจอข้อมูลที่เราค้นหาแล้ว
    - ถ้าเกิดข้อมูลน้อยกว่าสิ่งที่เราค้นหา ให้ค่า $L = mid+1$ (เพราะไม่มีทางที่ข้อมูลที่เราต้องการ อยู่ระหว่าง $L$ และ $mid$ แน่นอน)
    - ถ้าเกิดข้อมูลมากกว่าสิ่งที่เราค้นหา ให้ค่า $R = mid-1$ (หลักการเดียวกันกับข้างต้น)
4. ทำซ้ำไปเรื่อยๆ จนกว่า $L > R$ (แสดงว่าไม่มีข้อมูลที่ค้นหาอยู่) หรือพบข้อมูลที่ต้องการ

!!! warning "หมายเหตุ"
    1. สามารถหาค่า $mid$ ได้หลายวิธี โดยปกติมักทำโดยการนำค่า $\frac{L+R}{2}$ ปัดเศษลง แต่ก็สามารถปัดเศษขึ้นได้เหมือนกัน
    2. การกำหนดค่า $L$ และ $R$ ใหม่ ก็สามารถทำได้หลายวิธี เช่น ถ้าเกิดมีข้อมูลซ้ำ และเราต้องการหาข้อมูลที่ตรงและมีตำแหน่งมากที่สุด อาจเปลี่ยนจาก $R = mid-1$ เป็น $R = mid$ แทน

## Binary search ในชีวิตประจำวัน

เราอาจใช้ Binary search ในชีวิตประจำวันโดยไม่รู้ตัว ตัวอย่างการใช้งานเช่น:

มีหนังสือ 8 เล่ม โดยที่ชื่อหนังสือแต่ละเล่มนั้น **เรียงลำดับตามพจนานุกรม** ตามตาราง

| หนังสือเล่มที่ | ชื่อหนังสือ |
| ----- | ----------- |
| 1 | Ascendance of a bookworm |
| 2 | Harry potter |
| 3 | Jobless Reincarnation |
| 4 | Lycoris Recoil |
| 5 | Omniscient Reader's Viewpoint |
| 6 | Reverend Insanity |
| 7 | Secrets of the Silent Witch |
| 8 | The Beginning After The End |

ถ้าเกิดต้องการหาว่า "Omniscient Reader's Viewpoint" เป็นหนังสือเล่มที่เท่าไหร่ จะมีวิธีหลักๆ อยู่ 2 วิธี คือ

### วิธีที่ 1 (Sequential search หรือ Linear search)

1. ตรวจสอบหนังสือเล่มที่ 1 สังเกตว่าหนังสือเล่มนั้นไม่ใช่ "Omniscient Reader's Viewpoint" จึงไปดูหนังสือเล่มต่อไป
2. ตรวจสอบหนังสือเล่มที่ 2 สังเกตว่าหนังสือเล่มนั้นไม่ใช่ "Omniscient Reader's Viewpoint" จึงไปดูหนังสือเล่มต่อไป
3. ทำซ้ำไปเรื่อยๆ จนเจอ "Omniscient Reader's Viewpoint" หรือดูหนังสือครบทุกเล่ม

### วิธีที่ 2 (Binary search)

1. สังเกตว่า มีหนังสือ 8 เล่ม
2. ตรวจสอบหนังสือเล่มที่ 4 หรือ 5 เนื่องจากทั้งตำแหน่งกึ่งกลางอาจเป็น 4 หรือ 5 ก็ได้ ในที่นี้เราเลือกหนังสือเล่มที่ 4 สังเกตว่า "Lycoris recoil" มาก่อน "Omniscient Reader's Viewpoint" ตามลำดับพจนานุกรม ดังนั้น หนังสือเล่มที่ 1 ถึง 4 ไม่มีทางเป็น "Omniscient Reader's Viewpoint" แน่นอน หนังสือที่เป็นไปได้จึงเป็นหนังสือเล่มที่ 5 ถึง 8
3. ตรวจสอบหนังสือเล่มที่ 6 หรือ 7 ในที่นี้เราเลือกหนังสือเล่มที่ 7 สังเกตว่า "Secrets of the Silent Witch" มาหลัง "Omniscient Reader's Viewpoint" ตามลำดับพจนานุกรม ดังนั้น หนังสือที่เป็นไปได้จึงเป็นหนังสือเล่มที่ 5 ถึง 6
4. ตรวจสอบหนังสือเล่มที่ 5 ซึ่งมีชื่อ "Omniscient Reader's Viewpoint" ตามที่เราต้องการ จึงสามารถสรุปได้ว่า "Omniscient Reader's Viewpoint" เป็นหนังสือเล่มที่ 5

## Binary search vs Sequential search

สังเกตว่า วิธีที่ 1 จำเป็นต้องตรวจสอบหนังสืออย่างมาก 8 เล่ม แต่วิธีที่ 2 จำเป็นต้องตรวจสอบหนังสือแค่ 3 เล่ม ซึ่งดูเหมือนจะไม่ได้เร็วขึ้นกว่ากันมาก แต่ถ้าเกิดมีหนังสือ 1 ล้านเล่ม วิธีที่ 2 จะตรวจสอบหนังสือแค่ 20 เล่มเท่านั้น

ถ้าเกิดมีหนังสือ n เล่ม

- วิธีที่ 1 (sequential search) ตรวจสอบอย่างมาก n ครั้ง หรือ $O(n)$
- วิธีที่ 2 (binary search) ตรวจสอบอย่างมาก $\lceil \log_2 n\rceil$ ครั้ง หรือ $O(\log n)$

!!! info "ข้อสังเกต"
    Binary search สามารถใช้ได้กับข้อมูลที่มีการเรียงแล้วเท่านั้น

## Binary Search กับ Competitive Programming

!!! abstract "โจทย์ตัวอย่าง"
    รับจำนวนเต็มมา $n$ จำนวน $a_1, a_2, ..., a_n$ โดยที่ $a_i \leq a_{i+1}$ สำหรับ $1 \leq i \leq n-1$

    ต้องการถาม $q$ คำถาม ในคำถามที่ $i$ ให้ตอบว่ามีกี่ตัวเลขใน $n$ ตัวเลขนี้ ที่มีค่าอยู่ระหว่าง $x_i$ และ $y_i$ โดยที่ constraints เป็นดังนี้

    $1 \leq n, q \leq 100,000$

    $1 \leq a_1, ..., a_n \leq 10^9$

สังเกตว่า ในโจทย์ข้อนี้ ถ้าหากตรวจสอบทุกตัวเลข ในแต่ละคำถาม จะใช้เวลา $O(nq)$ ซึ่งไม่พอต่อขอบเขตข้อมูลของโจทย์

เราสามารถหาว่า มีเลขกี่ตัวที่น้อยกว่าหรือเท่ากับ $A$ ได้ ใน $O(\log n)$ ด้วย binary search โดย:

1. กำหนดตำแหน่งข้อมูลที่น้อย และมากที่สุดที่เป็นไปได้ (ให้ $L=0,R=n$)
2. หาค่าตรงกลาง ระหว่าง $L$ กับ $R$ ให้ค่านี้เป็น $mid$
3. ตรวจสอบข้อมูลในตำแหน่ง $mid$
    - ถ้าเกิดข้อมูลน้อยกว่าหรือเท่ากับเลขที่เราค้นหา ให้ค่า $L = mid+1$
    - ถ้าเกิดไม่ใช่ ให้ค่า $R = mid$
4. ทำซ้ำไปเรื่อยๆ จนกว่า $L = R$
5. จะได้ว่า $L$ เป็นตำแหน่งของเลขตัวแรก ที่มีค่ามากกว่า $A$ ดังนั้นจำนวนเลขกี่ตัวที่น้อยกว่าหรือเท่ากับ $A$ มี $L$ จำนวน

!!! info "ข้อสังเกต"
    การ binary search ในที่นี้ จะมีลักษณะเหมือนฟังก์ชั่น `std::upper_bound` และ `std::lower_bound` ในภาษา C++ ดังนั้นสามารถใช้ฟังก์ชั่นนี้โดยตรงได้เลย (จริงๆ แล้ว ทั้งสองฟังก์ชั่นใช้ binary search ในการค้นหาตำแหน่ง)

ในการแก้โจทย์ข้อนี้ เราจะหาตำแหน่งของ 2 ตัวเลข คือ จำนวนตัวเลขที่น้อยกว่าหรือเท่ากับ $x_i-1$ (ให้ค่าเป็น $P$) และจำนวนตัวเลขที่น้อยกว่าหรือเท่ากับ $y_i$ (ให้ค่าเป็น $Q$) สำหรับแต่ละคำถาม สามารถตอบ $Q-P$ ได้เลย

สรุป Time complexity:

- การรับข้อมูล: $O(n)$
- ถามแต่ละคำถาม: $O(\log n) \rightarrow$ ถาม 2$q$ ครั้ง จะได้ time complexity เป็น $O(q \log n)$

Time complexity รวม: $O(n+q \log n)$ ซึ่งเพียงพอต่อความต้องการของโจทย์

ตัวอย่างโค้ด (ไม่ใช้ `std::upper_bound`)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q, arr[100001];
int search(int num) {
    int l = 0, r = n;
    while(l < r) {
        int mid = (l+r)/2;
        if(arr[mid] <= num) {
            l = mid+1;
        } else {
            r = mid;
        }
    }
    return l;
}
int main() {
    cin >> n >> q;
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }
    sort(arr, arr+n);
    for(int i=0; i<q; i++) {
        int a, b;
        cin >> a >> b;
        cout << search(b) - search(a-1) << "\n";
    }
}
```

!!! warning "ข้อผิดพลาดที่เกิดขึ้นบ่อย"
    1. การที่เราหาค่า mid โดยการใช้สมการ $(L+R)/2$ อาจทำให้เกิด overflow ขึ้นได้ เพราะระหว่างการคำนวณ ค่า $(L+R)$ จะมีค่ามากกว่าทั้งค่า L และ R ที่โจทย์กำหนด โดยสามารถแก้ได้โดยการใช้สมการ $L + (R-L)/2$

ตัวอย่างโค้ด (ใช้ `std::upper_bound`)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q, arr[100001];
int main() {
    int n, q;
    cin >> n >> q;
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }
    sort(arr, arr+n);
    for(int i=0; i<q; i++) {
        int x, y;
        cin >> x >> y;
        cout << upper_bound(arr, arr+n, y) - upper_bound(arr, arr+n, x-1) << "\n";
    }
}
```

!!! note "คำแนะนำ"
    ถ้าเกิดข้อมูลไม่ได้เรียงมาให้ กล่าวคือ $a_i \leq a_{i+1}$ ไม่เป็นจริงเสมอไป สามารถจัดเรียงข้อมูลโดยใช้ `std::sort` (หรืออาจเป็นฟังก์ชั่นอื่นในภาษาอื่น) ก่อน เพื่อทำขึ้นตอนต่อไปได้ ซึ่งมี Time complexity เป็น $O(n \log n)$

!problems [CF-706B, TOI14-nbk, TOI18-shopping, CF-2112C]

## Binary search on answer

!!! abstract "โจทย์ตัวอย่าง: กุลีแห่งท่าเรือ - การแข่งขันคอมพิวเตอร์โอลิมปิกระดับชาติครั้งที่ 11"
    [โจทย์](https://programming.in.th/tasks/toi11_labor)

    โจทย์โดยย่อ: มีกุลีทั้งหมด $m$ คน กุลีคนที่ $i$ จะใช้เวลา $t_i$ นาที ในการขนสินค้า 1 ชิ้นขึ้นเรือ อยากทราบว่า ถ้าต้องการขนสินค้า $n$ ชิ้นขึ้นเรือ โดยใช้กุลีทั้ง $m$ คน จะใช้เวลาน้อยที่สุดเท่าไหร่ โดยมี constraints ดังนี้

    $2\leq m\leq 10^6$

    $1\leq n\leq 10^{12}$

    $1\leq t_i\leq 10^6$ สำหรับ $1\leq i\leq m$

!unfinished