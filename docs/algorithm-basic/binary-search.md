---
title: Binary Search
author: njoop
level: 
---

## Binary Search คืออะไร

Binary Search หรือการค้นหาแบบทวิภาค เป็นวิธีการค้นหาข้อมูลที่ใช้กับข้อมูลที่**มีการเรียงลำดับแล้ว** โดยจะนำข้อมูลมาแบ่งครึ่ง และพิจารณาว่าข้อมูลที่ต้องการจะค้นหาอยู่ที่ครึ่งไหน และทำซ้ำๆ ไปเรื่อยๆ

Binary search สามารถทำได้โดยมีขั้นตอนดังนี้

1. กำหนดตำแหน่งข้อมูลที่น้อย และมากที่สุดที่เป็นไปได้ (แทนค่าด้วยตัวแปร $L$, $R$ ตามลำดับ โดยช่วง $[L, R]$ จะเป็นช่วงที่เป็นไปได้ที่มจะมีข้อมูลที่เราต้องการค้นหาอยู่)
2. หาค่าตรงกลาง ระหว่าง $L$ กับ $R$ ให้ค่านี้เป็น $mid$
3. ตรวจสอบข้อมูลในตำแหน่ง $mid$
    - ถ้าเกิดข้อมูลเป็นสิ่งที่เราค้นหา ก็จบการทำงาน โดยเราพบเจอข้อมูลที่เราค้นหาแล้ว
    - ถ้าเกิดข้อมูลน้อยกว่าสิ่งที่เราค้นหา ให้ค่า $L = mid+1$ (เพราะไม่มีทางที่ข้อมูลที่เราต้องการ อยู่ระหว่าง $L$ และ $mid$ แน่นอน)
    - ถ้าเกิดข้อมูลมากกว่าสิ่งที่เราค้นหา ให้ค่า $R = mid-1$ (หลักการเดียวกันกับข้างต้น)
4. ทำซ้ำไปเรื่อยๆ จนกว่า $L > R$ (แสดงว่าไม่มีข้อมูลที่ค้นหาอยู่) หรือพบข้อมูลที่ต้องการ

!!! warning "หมายเหตุ"
    1. สามารถหาค่า $mid$ ได้หลายวิธี โดยปกติมักทำโดยการนำค่า $\frac{L+R}{2}$ ปัดเศษลง แต่ก็สามารถปัดเศษขึ้นได้เหมือนกัน
    2. การกำหนดค่า $L$ และ $R$ ใหม่ ก็สามารถทำได้หลายวิธี เช่น ถ้าเกิดมีข้อมูลซ้ำ และเราต้องการหาข้อมูลที่ตรงและมีตำแหน่งมากที่สุด อาจเปลี่ยนจาก $R = mid-1$ เป็น $R = mid$ แทน

## Binary search ในชีวิตประจำวัน

เราอาจใช้ Binary search ในชีวิตประจำวันโดยไม่รู้ตัว ตัวอย่างการใช้งานเช่น:

มีหนังสือ 8 เล่ม โดยที่ชื่อหนังสือแต่ละเล่มนั้น **เรียงลำดับตามพจนานุกรม** ตามตาราง

| หนังสือเล่มที่ | ชื่อหนังสือ |
| ----- | ----------- |
| 1 | Ascendance of a bookworm |
| 2 | Harry potter |
| 3 | Jobless Reincarnation |
| 4 | Lycoris Recoil |
| 5 | Omniscient Reader's Viewpoint |
| 6 | Reverend Insanity |
| 7 | Secrets of the Silent Witch |
| 8 | The Beginning After The End |

ถ้าเกิดต้องการหาว่า "Omniscient Reader's Viewpoint" เป็นหนังสือเล่มที่เท่าไหร่ จะมีวิธีหลักๆ อยู่ 2 วิธี คือ

### วิธีที่ 1 (Sequential search หรือ Linear search)

1. ตรวจสอบหนังสือเล่มที่ 1 สังเกตว่าหนังสือเล่มนั้นไม่ใช่ "Omniscient Reader's Viewpoint" จึงไปดูหนังสือเล่มต่อไป
2. ตรวจสอบหนังสือเล่มที่ 2 สังเกตว่าหนังสือเล่มนั้นไม่ใช่ "Omniscient Reader's Viewpoint" จึงไปดูหนังสือเล่มต่อไป
3. ทำซ้ำไปเรื่อยๆ จนเจอ "Omniscient Reader's Viewpoint" หรือดูหนังสือครบทุกเล่ม

### วิธีที่ 2 (Binary search)

1. สังเกตว่า มีหนังสือ 8 เล่ม
2. ตรวจสอบหนังสือเล่มที่ 4 หรือ 5 เนื่องจากทั้งตำแหน่งกึ่งกลางอาจเป็น 4 หรือ 5 ก็ได้ ในที่นี้เราเลือกหนังสือเล่มที่ 4 สังเกตว่า "Lycoris recoil" มาก่อน "Omniscient Reader's Viewpoint" ตามลำดับพจนานุกรม ดังนั้น หนังสือเล่มที่ 1 ถึง 4 ไม่มีทางเป็น "Omniscient Reader's Viewpoint" แน่นอน หนังสือที่เป็นไปได้จึงเป็นหนังสือเล่มที่ 5 ถึง 8
3. ตรวจสอบหนังสือเล่มที่ 6 หรือ 7 ในที่นี้เราเลือกหนังสือเล่มที่ 7 สังเกตว่า "Secrets of the Silent Witch" มาหลัง "Omniscient Reader's Viewpoint" ตามลำดับพจนานุกรม ดังนั้น หนังสือที่เป็นไปได้จึงเป็นหนังสือเล่มที่ 5 ถึง 6
4. ตรวจสอบหนังสือเล่มที่ 5 ซึ่งมีชื่อ "Omniscient Reader's Viewpoint" ตามที่เราต้องการ จึงสามารถสรุปได้ว่า "Omniscient Reader's Viewpoint" เป็นหนังสือเล่มที่ 5

## Binary search vs Sequential search

สังเกตว่า วิธีที่ 1 จำเป็นต้องตรวจสอบหนังสืออย่างมาก 8 เล่ม แต่วิธีที่ 2 จำเป็นต้องตรวจสอบหนังสือแค่ 3 เล่ม ซึ่งดูเหมือนจะไม่ได้เร็วขึ้นกว่ากันมาก แต่ถ้าเกิดมีหนังสือ 1 ล้านเล่ม วิธีที่ 2 จะตรวจสอบหนังสือแค่ 20 เล่มเท่านั้น

ถ้าเกิดมีหนังสือ n เล่ม

- วิธีที่ 1 (sequential search) ตรวจสอบอย่างมาก n ครั้ง หรือ $O(n)$
- วิธีที่ 2 (binary search) ตรวจสอบอย่างมาก $\lceil \log_2 n\rceil$ ครั้ง หรือ $O(\log n)$

!!! info "ข้อสังเกต"
    Binary search สามารถใช้ได้กับข้อมูลที่มีการเรียงแล้วเท่านั้น

## Binary Search กับ Competitive Programming

!!! abstract "โจทย์ตัวอย่าง"
    รับจำนวนเต็มมา $n$ จำนวน $a_1, a_2, ..., a_n$ โดยที่ $a_i \leq a_{i+1}$ สำหรับ $1 \leq i \leq n-1$

    ต้องการถาม $q$ คำถาม ในคำถามที่ $i$ ให้ตอบว่ามีกี่ตัวเลขใน $n$ ตัวเลขนี้ ที่มีค่าอยู่ระหว่าง $x_i$ และ $y_i$ โดยที่ constraints เป็นดังนี้

    $1 \leq n, q \leq 100,000$

    $1 \leq a_1, ..., a_n \leq 10^9$

สังเกตว่า ในโจทย์ข้อนี้ ถ้าหากตรวจสอบทุกตัวเลข ในแต่ละคำถาม จะใช้เวลา $O(nq)$ ซึ่งไม่พอต่อขอบเขตข้อมูลของโจทย์

เราสามารถหาว่า มีเลขกี่ตัวที่น้อยกว่าหรือเท่ากับ $A$ ได้ ใน $O(\log n)$ ด้วย binary search โดย:

1. กำหนดตำแหน่งข้อมูลที่น้อย และมากที่สุดที่เป็นไปได้ (ให้ $L=0,R=n$)
2. หาค่าตรงกลาง ระหว่าง $L$ กับ $R$ ให้ค่านี้เป็น $mid$
3. ตรวจสอบข้อมูลในตำแหน่ง $mid$
    - ถ้าเกิดข้อมูลน้อยกว่าหรือเท่ากับเลขที่เราค้นหา ให้ค่า $L = mid+1$
    - ถ้าเกิดไม่ใช่ ให้ค่า $R = mid$
4. ทำซ้ำไปเรื่อยๆ จนกว่า $L = R$
5. จะได้ว่า $L$ เป็นตำแหน่งของเลขตัวแรก ที่มีค่ามากกว่า $A$ ดังนั้นจำนวนเลขกี่ตัวที่น้อยกว่าหรือเท่ากับ $A$ มี $L$ จำนวน

!!! info "ข้อสังเกต"
    การ binary search ในที่นี้ จะมีลักษณะเหมือนฟังก์ชั่น `std::upper_bound` และ `std::lower_bound` ในภาษา C++ ดังนั้นสามารถใช้ฟังก์ชั่นนี้โดยตรงได้เลย (จริงๆ แล้ว ทั้งสองฟังก์ชั่นใช้ binary search ในการค้นหาตำแหน่ง)

ในการแก้โจทย์ข้อนี้ เราจะหาตำแหน่งของ 2 ตัวเลข คือ จำนวนตัวเลขที่น้อยกว่าหรือเท่ากับ $x_i-1$ (ให้ค่าเป็น $P$) และจำนวนตัวเลขที่น้อยกว่าหรือเท่ากับ $y_i$ (ให้ค่าเป็น $Q$) สำหรับแต่ละคำถาม สามารถตอบ $Q-P$ ได้เลย

สรุป Time complexity:

- การรับข้อมูล: $O(n)$
- ถามแต่ละคำถาม: $O(\log n) \rightarrow$ ถาม 2$q$ ครั้ง จะได้ time complexity เป็น $O(q \log n)$

Time complexity รวม: $O(n+q \log n)$ ซึ่งเพียงพอต่อความต้องการของโจทย์

ตัวอย่างโค้ด (ไม่ใช้ `std::upper_bound`)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q, arr[100001];
int search(int num) {
    int l = 0, r = n;
    while(l < r) {
        int mid = (l+r)/2;
        if(arr[mid] <= num) {
            l = mid+1;
        } else {
            r = mid;
        }
    }
    return l;
}
int main() {
    cin >> n >> q;
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }
    sort(arr, arr+n);
    for(int i=0; i<q; i++) {
        int a, b;
        cin >> a >> b;
        cout << search(b) - search(a-1) << "\n";
    }
}
```

!!! warning "ข้อผิดพลาดที่เกิดขึ้นบ่อย"
    1. การที่เราหาค่า mid โดยการใช้สมการ $(L+R)/2$ อาจทำให้เกิด overflow ขึ้นได้ เพราะระหว่างการคำนวณ ค่า $(L+R)$ จะมีค่ามากกว่าทั้งค่า L และ R ที่โจทย์กำหนด โดยสามารถแก้ได้โดยการใช้สมการ $L + (R-L)/2$

ตัวอย่างโค้ด (ใช้ `std::upper_bound`)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q, arr[100001];
int main() {
    int n, q;
    cin >> n >> q;
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }
    sort(arr, arr+n);
    for(int i=0; i<q; i++) {
        int x, y;
        cin >> x >> y;
        cout << upper_bound(arr, arr+n, y) - upper_bound(arr, arr+n, x-1) << "\n";
    }
}
```

!!! note "คำแนะนำ"
    ถ้าเกิดข้อมูลไม่ได้เรียงมาให้ กล่าวคือ $a_i \leq a_{i+1}$ ไม่เป็นจริงเสมอไป สามารถจัดเรียงข้อมูลโดยใช้ `std::sort` (หรืออาจเป็นฟังก์ชั่นอื่นในภาษาอื่น) ก่อน เพื่อทำขึ้นตอนต่อไปได้ ซึ่งมี Time complexity เป็น $O(n \log n)$

!problems [CF-706B, TOI14-nbk, TOI18-shopping, CF-2112C]

## Binary search on answer

!!! abstract "โจทย์ตัวอย่าง: กุลีแห่งท่าเรือ - การแข่งขันคอมพิวเตอร์โอลิมปิกระดับชาติครั้งที่ 11"
    [โจทย์](https://programming.in.th/tasks/toi11_labor)

    โจทย์โดยย่อ: มีกุลีทั้งหมด $m$ คน กุลีคนที่ $i$ จะใช้เวลา $t_i$ นาที ในการขนสินค้า 1 ชิ้นขึ้นเรือ อยากทราบว่า ถ้าต้องการขนสินค้า $n$ ชิ้นขึ้นเรือ โดยใช้กุลีทั้ง $m$ คน จะใช้เวลาน้อยที่สุดเท่าไหร่ โดยมี constraints ดังนี้

    $2\leq m\leq 10^6$

    $1\leq n\leq 10^{12}$

    $1\leq t_i\leq 10^6$ สำหรับ $1\leq i\leq m$

Binary search on answer คือการเอาแนวคิด Binary Search มาใช้กับ *คำตอบ* โดยเราจะหาค่าคำตอบกลาง แล้วตรวจสอบว่าคำตอบกลางนั้น เพียงพอหรือยัง ถ้าเพียงพอ (หรือมากไป) ก็ลดช่วง ถ้าทำยังไม่พอ ก็ขยายช่วง คล้ายการถามว่า คำตอบนี้ผ่านเงื่อนไขหรือยัง แล้วไล่หาคำตอบที่เล็กที่สุด (หรือใหญ่ที่สุด) ที่ทำให้เงื่อนไขเป็นจริง

### วิเคราะห์โจทย์

ในเวลา $T$ นาที กุลีคนที่ $i$ จะขนของได้ $\left\lfloor \dfrac{T}{t_i} \right\rfloor$ ชิ้น (เพราะทุกๆ $t_i$ นาที ขนได้ 1 ชิ้น) ดังนั้นของทั้งหมดที่ขนได้รวมคือ

$$ f(T) = \sum_{i=1}^{m} \left\lfloor \frac{T}{t_i} \right\rfloor $$

สังเกตว่า $f(T)$ จะเพิ่มขึ้น เมื่อ $T$ เท่าเดิมหรือมากขึ้น (ไม่ลดลง) $f(T)$ จึงเป็นฟังก์ชันโมโนโทน

โดยในโจทย์นี้เราต้องการหา $T$ ที่เล็กที่สุดที่ทำให้ $f(T) \geq n$

!!! info "ฟังก์ชันโมโนโทนคืออะไร"
    ฟังก์ชันโมโนโทน (Monotone Function) หมายถึงฟังก์ชันที่ค่าของมัน **ไม่ลดลง** หรือ **ไม่เพิ่มขึ้น** เมื่ออินพุตเพิ่มขึ้น  
    - **โมโนโทนเพิ่ม (monotone increasing / non-decreasing):** ถ้า $x_1 < x_2$ แล้ว $f(x_1) \leq f(x_2)$  
    - **โมโนโทนลด (monotone decreasing / non-increasing):** ถ้า $x_1 < x_2$ แล้ว $f(x_1) \geq f(x_2)$  

    ในที่นี้ $f(T)$ เป็นฟังก์ชันโมโนโทนเพิ่ม เพราะเมื่อเวลา $T$ มากขึ้น จำนวนของที่ขนได้จะไม่ลดลง

### กำหนดช่วงการค้นหา

- เวลาน้อยที่สุดที่เป็นไปได้: 1 (ถ้า $n=0$ ก็เป็น 0 แต่ในโจทย์ $n\geq 1$)
- เวลามากที่สุด: ถ้าเอากุลีที่ช้าที่สุดคนเดียวทำทั้งหมด ใช้เวลา $\max(t_i)\times n$ แต่เราจะเลือกช่วงที่ดีกว่านี้ โดยใช้กุลีที่เร็วที่สุด: เวลามากสุดไม่เกิน $\min(t_i)\times n$

ดังนั้นตั้ง $L = 1$, $R = \min(t_i)\times n$

### ขั้นตอนการ Binary Search on Answer

1. ตั้ง $L = 1$, $R = \min(t_i)\times n$
2. วนในขณะที่ $L < R$
    - หาค่า $mid = (L + R) / 2$
    - คำนวณ $f(mid)$ = จำนวนชิ้นที่ขนได้ภายในเวลา $mid$
    - ถ้า $f(mid) \geq n$ แปลว่าเวลา $mid$ เพียงพอ อาจมีคำตอบที่น้อยกว่านี้ได้ ปรับ $R = mid - 1$
    - ถ้า $f(mid) < n$ แปลว่ายังไม่พอ ต้องเพิ่มเวลา ปรับ $L = mid + 1$
3. ตอนจบจะมี $L = R$ เป็นเวลาน้อยที่สุดที่ขนได้ครบ $n$ ชิ้น

### ตัวอย่างที่ 1

กุลี 2 คน: $t = [7, 12]$, ต้องขน $n = 5$ ชิ้น

กำหนด $L = 1$, $R = 5\times 7 = 35$ (เพราะ $\min t_i = 7$)

Binary Search on Answer :

- mid = 18: ขนได้ $\lfloor18/7\rfloor+\lfloor18/12\rfloor = 2+1=3 < 5$ (ยังไม่พอ) ⇒ $L = 19$
- mid = 22: ขนได้ $\lfloor22/7\rfloor+\lfloor22/12\rfloor = 3+1=4 < 5$ (ยังไม่พอ) ⇒ $L = 23$
- mid = 29: ขนได้ $\lfloor29/7\rfloor+\lfloor29/12\rfloor = 4+2=6 \geq 5$ (หาค่าที่ดีกว่า) ⇒ $R = 29$
- mid = 26: ขนได้ $\lfloor26/7\rfloor+\lfloor26/12\rfloor = 3+2=5 \geq 5$ (หาค่าที่ดีกว่า) ⇒ $R = 26$
- mid = 24: ขนได้ $\lfloor24/7\rfloor+\lfloor24/12\rfloor = 3+2=5 \geq 5$ (หาค่าที่ดีกว่า) ⇒ $R = 24$
- mid = 23: ขนได้ $\lfloor23/7\rfloor+\lfloor23/12\rfloor = 3+1=4 < 5$ (ยังไม่พอ) ⇒ $L = 24$

สรุป $L = R = 24$ คำตอบคือ 24 นาที

### ตัวอย่างที่ 2

กุลี 3 คน: $t = [2, 6, 13]$, ต้องขน $n = 3$ ชิ้น

กำหนด $L = 1$, $R = 2\times  3 = 6$ (เพราะ $\min t_i = 2$)

Binary Search on Answer :

- mid = 3: ขนได้ $\lfloor3/2\rfloor+\lfloor3/6\rfloor+\lfloor3/13\rfloor=1+0+0=1 < 3$ (ยังไม่พอ) ⇒ $L = 4$
- mid = 5: ขนได้ $\lfloor5/2\rfloor+\lfloor5/6\rfloor+\lfloor5/13\rfloor=2+0+0=2 < 3$ (ยังไม่พอ) ⇒ $L = 6$

สรุป $L = R = 6$ คำตอบคือ 6 นาที

??? note "โค้ดเฉลย"
    === "C"
        ```c
        #include <stdio.h>
        #include <stdbool.h>

        int t[1000005];
        long long n;
        int m;

        bool check(long long x) {
            long long ans = 0;
            for (int i = 0; i < m; i++) {
                ans += (x / t[i]);
                if (ans >= n)
                    return true;
            }
            return false;
        }

        int main() {
            scanf("%d %lld", &m, &n);
            long long mn_element = 1000000;
            for (int i = 0; i < m; i++) {
                scanf("%d", &t[i]);
                if (t[i] < mn_element)
                    mn_element = t[i];
            }
            long long l = 1, r = mn_element * n, ans = 0;
            while (l < r) {
                long long mid = (l + r) / 2;
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            printf("%lld", l);
        }
        ```
    === "C++"
        ```cpp
        #include <iostream>
        using namespace std;

        int t[1000005];
        long long n;
        int m;

        bool check(long long x) {
            long long ans = 0;
            for (int i = 0; i < m; i++) {
                ans += (x / t[i]);
                if (ans >= n)
                    return true;
            }
            return false;
        }

        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
            cin >> m >> n;
            long long mn_element = 1000000;
            for (int i = 0; i < m; i++) {
                cin >> t[i];
                if(t[i] < mn_element)
                    mn_element = t[i];
            }
            long long l = 1, r = mn_element * n, ans = 0;
            while (l < r) {
                long long mid = (l + r) / 2;
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            cout << l;
        }
        ```

### สรุป Time Complexity

- ฟังก์ชันตรวจสอบ `check(mid)` ใช้เวลา $O(m)$
- จำนวนรอบ binary search คือ $O(\log (m\times n))$
- รวม: $O(m \log (m\times n))$ ซึ่งเพียงพอต่อความต้องการของโจทย์

!!! warning "ข้อผิดพลาดที่เกิดขึ้นบ่อย"
    1. การที่เราหาค่า mid โดยการใช้สมการ $(L+R)/2$ อาจทำให้เกิด overflow ขึ้นได้ เพราะระหว่างการคำนวณ ค่า $(L+R)$ จะมีค่ามากกว่าทั้งค่า L และ R ที่โจทย์กำหนด โดยสามารถแก้ได้โดยการใช้สมการ $L + (R-L)/2$
    2. $m\times n$ อาจมากถึง $10^{18}$ จึงจำเป็นต้องใช้ `long long`

### รูปแบบ Binary Search on Answer ทั่วไป

```cpp
long long l = MIN_POSSIBLE; // ค่าต่ำสุดที่คำตอบเป็นไปได้
long long r = MAX_POSSIBLE; // ค่าสูงสุดที่คำตอบยังเป็นไปได้
while(l < r) {
    long long mid = l + (r - l) / 2; // candidate
    if(check(mid)) { // mid ใช้ได้ไหม
        r = mid;     // อยากหาตัวแรกที่จริง ลดช่วงลง
    } else {
        l = mid + 1; // ยังไม่พอ ต้องขยับไปทางขวา
    }
}
// l คือคำตอบ
```

### ใช้กับโจทย์แบบไหนได้บ้าง

- หา "ค่าน้อยที่สุด/มากที่สุด" ที่ทำให้เงื่อนไขผ่าน
- ปัญหาเกี่ยวกับเวลา ความเร็ว ความจุ ความยาว ความสูง จำนวนเงิน ฯลฯ ที่เมื่อเพิ่มขึ้น/ลดลง แล้วทำให้สถานะเปลี่ยนจาก false → true

!problems [TOI11-labor, CSES-Factory-Machines]
